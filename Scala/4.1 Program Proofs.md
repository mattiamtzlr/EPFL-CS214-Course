#scala 
# Induction on Programs
Mathematical proof by induction can also be used to test the correctness of programs.
> **Induction**
> $$P(0) \ \wedge \, \left( P(k) \ \Rightarrow \ P(k + 1) \right) \quad \Rightarrow \quad P(n) \qquad \forall n \gt k  \geq 0$$
> Where $P(n)$ is some statement which we want to prove.

This same idea can also be applied to computer programs, especially to functions. As Scala is a [[1.1 Background#Functional Programming| functional programming language]], it is especially suited for it.

## Induction on Functions
Take for example the closed formula for summing over the integers between `0` and `n`:
```Scala
def sum(n: Int): Int =
	if n == 0 then 0
	else n + sum(n - 1)
```
We can then use induction as follows:
> **Base case: n = 0**
> ```
> sum(0) := if 0 == 0 then 0
> 		  else 0 + sum(0 - 1)
>
> 		= 0
> ```

> **Induction step: n + 1, n >= 0**
> Inductive Hypothesis: sum(n) = n * (n + 1) / 2
> ```
> sum(n + 1) := if (n + 1) == 0 then 0
> 			  else (n + 1) + sum((n+ 1) - 1)
> 
> 			= if false then 0
> 			  else (n+1) + sum(n)
> 
> 			= (n+1) + sum(n)
> IH
> 			= (n+1) + n*(n+1)/2
> 			= (2*n+2) + n*n+n)/2
> 			= (n+1) * (n+2) / 2
> ```
The only problem that remains in comparison to purely mathematical proofs, is the fact that in programming, resources are finite. Thus a call to sum with a very large argument might lead to a `StackOverflow` error.
This needs to be considered when doing proofs.

## Structural Induction on... 
*Structural induction* is similar to normal induction with the main difference being that it works on data structures instead of on integers.
Thus, it first tests the variant of the data structure which represents the simplest form (usually an *empty* variant), and then tests all structures generated by the base case.

### ...Lists
For lists the base case is an empty list (`Nil` in Scala) and the induction case is:
For an arbitrary list `xs` and an element `x`, show: `P(xs) => P(x :: xs)`.

In the above, `::` is shorthand Scala syntax for [[4.3 Scala Lists, Tuples#List Constructors|constructing a list]].

For this to work, the list need to have finite, non-negative length, which is usually given.

An example can be found on [[scala-week4.pdf|slides 17 - 24]].

### ...Trees


## Summary
A valid equation is defined by:
1. Symbolic execution of functions (using defining equations)
2. Reflexivity: `E == E`
3. Symmetry: `E == F => F == E`
4. Transitivity: `(E == F && F == G) => E == G`
5. Instantiation, example:
   `(x :: (y :: Nil)).length == 2 => (42 :: (5 :: Nil)).length == 2`
6. Substitution, example:
   `f(x) = x + 1 => 3 + f(x) == 3 + x + 1`
7. Structural Induction

# Automated Proof Checking
