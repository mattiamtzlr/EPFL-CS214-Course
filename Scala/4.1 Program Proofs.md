#scala 
# Induction on Programs
Mathematical proof by induction can also be used to test the correctness of programs.
> [!example]- **Induction**
> Mathematical induction acts on the following proposition:
> $$P(0) \ \wedge \, \left( P(k) \ \Rightarrow \ P(k + 1) \right) \quad \Rightarrow \quad P(n) \qquad \forall n \gt k  \geq 0$$
> Where $P(n)$ is some statement which we want to prove.

This same idea can also be applied to computer programs, especially to functions. As Scala is a  functional programming language, it is especially suited for it.

## Induction on Functions
Take for example the closed formula for summing over the integers between `0` and `n`:
```Scala
def sum(n: Int): Int =
	if n == 0 then 0
	else n + sum(n - 1)
```
We can then use induction as follows:
> **Base case: n = 0**
> ```
> sum(0) := if 0 == 0 then 0
> 		  else 0 + sum(0 - 1)
>
> 		= 0
> ```

> **Induction step: n + 1, n >= 0**
> Inductive Hypothesis: sum(n) = n * (n + 1) / 2
> ```
> sum(n + 1) := if (n + 1) == 0 then 0
> 			  else (n + 1) + sum((n+ 1) - 1)
> 
> 			= if false then 0
> 			  else (n+1) + sum(n)
> 
> 			= (n+1) + sum(n)
> IH
> 			= (n+1) + n*(n+1)/2
> 			= (2*n+2) + n*n+n)/2
> 			= (n+1) * (n+2) / 2
> ```
The only problem that remains in comparison to purely mathematical proofs, is the fact that in programming, resources are finite. Thus a call to sum with a very large argument might lead to a `StackOverflow` error.
This needs to be considered when doing proofs.

<br>

## Structural Induction on... 
*Structural induction* is similar to normal induction with the main difference being that it works on data structures instead of on integers.
Thus, it first tests the variant of the data structure which represents the simplest form (usually an *empty* variant), and then tests all structures generated by the base case.

### ...Lists
For lists the base case is an empty list (`Nil` in Scala) and the induction case is:
For an arbitrary list `xs` and an element `x`, show: `P(xs) => P(x :: xs)`.

In the above, `::` is shorthand Scala syntax for [[4.3 Scala Lists, Tuples#List Constructors|constructing a list]].

For this to work, the list need to have finite, non-negative length, which is usually given.

An example can be found on slides 17 - 24: 
![[scala-week4.pdf#page=17|slides 17 - 24]]

### ...Trees
Doing structural induction on trees is a bit different, the base step shows that `P(lf)` holds for all leaves `lf` of a tree.
The induction step is:
For all internal nodes `t` with subtrees `s1, ..., sN`, show that 
`(P(s1) && ... && P(sN)) => P(t)`.

An example can be found on slides 31 - 42:
![[scala-week4.pdf#page=31|slides 31 - 42]]

## Summary
A valid equation is defined by:
1. Symbolic execution of functions (using defining equations)
2. Reflexivity: `E == E`
3. Symmetry: `E == F => F == E`
4. Transitivity: `(E == F && F == G) => E == G`
5. Instantiation, example:
   `(x :: (y :: Nil)).length == 2 => (42 :: (5 :: Nil)).length == 2`
6. Substitution, example:
   `f(x) = x + 1 => 3 + f(x) == 3 + x + 1`
7. Structural Induction

# Automated Proof Checking
#terminology 

As it is pretty easy to make mistakes when doing long proofs with many cases, there are programs called *proof checkers*, designed to examine proof steps and to make sure that they are all valid according to rules of logic.

Proof checkers are the basis of *proof assistants* such as:
- [Coq](https://coq.inria.fr/)
- [Isabelle proof assistant](https://isabelle.in.tum.de/)
- [HOL prover](https://hol-theorem-prover.org/)
- [Lean proof assistant](https://lean-lang.org/)
- [Lisa proof framework](https://github.com/epfl-lara/lisa)

Programs that automatically and systematically search for proofs are called *Automated Theorem Provers (ATPs)*.
