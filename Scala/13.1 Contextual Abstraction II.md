#scala 

Until now, when talking about [[10.3 Contextual Abstraction I|contextual abstraction]], we mostly saw code following this pattern:
```Scala
trait Ordering[A]:
  def compare(x: A, y: A): Int

object Ordering:
  given Int: Ordering[Int] with
    def compare(x: Int, y: Int) =
      if x < y then -1 else if x > y then 1 else 0

  given String: Ordering[String] with
    def compare(x: String, y: String) = s.compareTo(t)

  given List: [T](using Ordering[T]): Ordering[List[T]] with
    def compare(x: List[T], y: List[T]) = ...
```

# Type Classes
#terminology 

We say that `Ordering` is a *type class*, which - in Scala - is a generic trait that comes with `given` instances for type instances of that trait.

Type classes provide yet another form of *polymorphism*, they can be used with all types for which there is a `given` instance. The specific implementation is resolved by the compiler at compile-time.
This is sometimes called *ad-hoc polymorphism*.
<br>

## Context Bounds
To use a `given` instance in a function, we use the `using TypeClass[T]` syntax, which is so common that there is an abbreviation for it:
```Scala
def sort[T: Ordering](xs: List[T]): List[T] = ...
         ^^^^^^^^^^^
```
which, in words, means that `sort` works for all types `T` that have an `Ordering`.

---

Context bounds can be used in [[10.3 Contextual Abstraction I#Conditional Instances|conditional]] `given` instances:
```Scala
given listOrdering[T: Ordering]: Ordering[List[T]] with ...
given pairOrdering[A: Ordering, B: Ordering]: Ordering[(A, B)] with ...
```
<br>

## Retroactive Extension
Let's say, we want to add an instance of the `Ordering` type class for the `Rational` type, which we have used before:
```Scala
case class Rational(number: Int, denom: Int)

given Ordering[Rational] with
  def compare(x: Rational, y: Rational) = 
    Ordering.Int.compare(x.numer * y.denom, y.numer * x.denom)
```

We were able to implement `Ordering[Rational]` without changing the definition of the `Rational` class. This is because type classes support *retroactive extension*: the ability to extend a data type with new operations without changing its definition.
Caveat: These retroactive extensions need to be defined or imported explicitly.