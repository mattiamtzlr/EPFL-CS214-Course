#software-engineering #debugging 

When [[3.A Debugging Process|debugging]], there are certain techniques which can (some shouldn't) be used to test your code.

# 1. Acceptance Testing
Get the users to use your code and thus test it for you:
```
Ship buggy software <----------------------+
	|                                      |
	V                                      |
Let users find the bugs and report them    |
	|                                      |
	V                                      |
Fix (some of) the bugs --------------------+
```

This annoys the users however.

# 2. System Testing
Use the code yourself.
```
Change the software <----------------------+
	|                                      |
	V                                      |
Go through use cases                       |
	|                                      |
	V                                      |
Fix (some of) the bugs --------------------+
```

This is very tedious.

# 3. Integration Testing
Run automated tests *end to end*, meaning the functionality of the whole code is tested at once.
```
Change the software <----------------------+
	|                                      |
	V                                      |
Run end to end tests                       |
	|                                      |
	V                                      |
Fix (some of) the bugs --------------------+
```

This does usually not find bugs which only appear in isolation.

# 4. Unit Tests
Run automated *single-component* tests which test only certain snippets of the code, in isolation.
```
Change the software <----------------------+
	|                                      |
	V                                      |
Run component tests                        |
	|                                      |
	V                                      |
Fix (some of) the bugs --------------------+
```

# 5. Pre/Post Conditions
In Scala, we have already seen the *preconditions* [[2.3 Data and Classes#`assert`|assert]] and [[2.3 Data and Classes#`require`|require]].

There is also the *postcondition* `ensuring`, which is designed to test the output of a function. For example for a function which sorts a list we could do the following:
```Scala
def sort(l: List[Int]): List[Int] = {
	...
} ensuring (res => (0 t0 l.length - 1).forall(
	idx => res(idx) <= res(idx + 1))
```
which, under the hood, gets transformed into:
```Scala
def sort(l: List[Int]): List[Int] = {
	val res = ...
	assert (0 to l.length - 2).forall(idx =>
		  res(idx) <= res(idx + 1))
	res
}
```
